use crate::git_repo::GitRepo;
use git2::Repository;
use std::fs;
use std::process::Command;

pub fn handle_commit(args: &[String]) -> Result<(), Box<dyn std::error::Error>> {
    // Check if user provided commit message or other flags that should bypass interactive mode
    let has_message_flag = args.iter().any(|arg| {
        arg == "-m"
            || arg == "--message"
            || arg == "-F"
            || arg == "--file"
            || arg == "-C"
            || arg == "--reuse-message"
            || arg == "-c"
            || arg == "--reedit-message"
            || arg == "--fixup"
            || arg == "--squash"
            || arg.starts_with("-m=")
            || arg.starts_with("--message=")
    });

    // If user provided message flags or other args, use passthrough mode
    if has_message_flag || !args.is_empty() {
        return passthrough_commit(args);
    }

    // Otherwise, use AI-assisted commit
    ai_commit()
}

fn passthrough_commit(args: &[String]) -> Result<(), Box<dyn std::error::Error>> {
    let mut cmd = Command::new("git");
    cmd.arg("commit");
    cmd.args(args);

    match cmd.status() {
        Ok(status) => {
            if !status.success() {
                std::process::exit(status.code().unwrap_or(1));
            }
        }
        Err(e) => {
            eprintln!("Error running git commit: {e}");
            std::process::exit(1);
        }
    }
    Ok(())
}

fn ai_commit() -> Result<(), Box<dyn std::error::Error>> {
    // Check if there are staged changes
    let git_repo = GitRepo::open(".")?;

    if !git_repo.has_staged_changes()? {
        eprintln!("No changes staged for commit.");
        return Ok(());
    }

    let repo = Repository::open(".")?;

    // Try to generate commit message with Claude
    let generated_message = generate_commit_message(&repo)?;

    if let Some(message) = generated_message {
        // Write generated message to a temporary file with comment
        let temp_file = "/tmp/gitx_commit_template";
        let template_content = format!(
            "{message}\n\n# Generated by gitx with Claude AI\n# Edit the message above and save to commit"
        );
        fs::write(temp_file, &template_content)?;

        // Use git commit with template
        let mut cmd = Command::new("git");
        cmd.arg("commit");
        cmd.arg("-t");
        cmd.arg(temp_file);
        cmd.arg("--allow-empty-message");

        let status = cmd.status()?;

        // Clean up
        let _ = fs::remove_file(temp_file);

        if !status.success() {
            std::process::exit(status.code().unwrap_or(1));
        }
    } else {
        // Fallback to normal git commit
        let status = Command::new("git").arg("commit").status()?;

        if !status.success() {
            std::process::exit(status.code().unwrap_or(1));
        }
    }

    Ok(())
}

fn generate_commit_message(
    _repo: &Repository,
) -> Result<Option<String>, Box<dyn std::error::Error>> {
    // Use GitRepo's diff_staged method for cleaner code
    let git_repo = GitRepo::open(".")?;
    let diff_text = git_repo.diff_staged()?;

    if diff_text.is_empty() {
        return Ok(None);
    }

    // Prepare the prompt for Claude
    let prompt = format!(
        "Based on the following git diff, generate a conventional commit message.

The message should follow this format:
<type>[optional scope]: <description>

[optional body]

Choose type from: feat, fix, docs, style, refactor, test, chore
Keep the description under 50 characters and use imperative mood.

Respond with ONLY the commit message, no additional text or formatting.

Git diff:
{diff_text}"
    );

    // Call Claude CLI with JSON output
    let output = Command::new("claude")
        .arg("--print")
        .arg("--output-format")
        .arg("json")
        .arg(&prompt)
        .output();

    match output {
        Ok(output) if output.status.success() => {
            let response = String::from_utf8_lossy(&output.stdout);

            // Parse Claude CLI JSON response and extract the result field
            if let Ok(json) = serde_json::from_str::<serde_json::Value>(&response)
                && let Some(message) = json.get("result").and_then(|r| r.as_str())
            {
                let message = message.trim();
                if !message.is_empty() {
                    return Ok(Some(message.to_string()));
                }
            }

            Ok(None)
        }
        _ => Ok(None), // Silently ignore errors to maintain graceful fallback
    }
}
